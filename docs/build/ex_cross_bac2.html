<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · Stochastic Frontier Analysis using Julia</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-134239283-1"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-134239283-1', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Stochastic Frontier Analysis using Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Stochastic Frontier Analysis using Julia</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home of SFrontiers.jl</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="overview.html">Estimation Overview</a></li><li><a class="tocitem" href="ex_detail.html">A Detailed Example</a></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Other Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ex_cross.html">cross-sectional models</a></li><li><a class="tocitem" href="ex_panel.html">panel models</a></li></ul></li><li><a class="tocitem" href="api.html">API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="ex_cross_bac2.html">-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="ex_cross_bac2.html">-</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>We use an example to go through the specification and estimation process of using <strong>SFrontiers</strong> to estimate a stochastic frontier (SF) model. The example is a cross-sectional stochastic production frontier model with the <strong>normal and truncated-normal</strong> distribution assumptions. Exogenous determinants are included in the model in the style of Battese and Coelli (1995).</p><ul><li><a href="ex_cross.html#crosssectional">Examples of Cross-Sectional Stochastic Frontier Models</a></li><ul><li><a href="ex_cross.html#Normal-Half-Normal">Normal Half-Normal</a></li><ul><ul><li><a href="ex_cross.html#vanilla-[(Aigner,-Lovell,-and-Schmidt-1977)](@ref-literature)">vanilla (Aigner, Lovell, and Schmidt 1977)</a></li><li><a href="ex_cross.html#with-inefficiency-determinants-[(Caudill-and-Ford-1993)](@ref-literature)">with inefficiency determinants (Caudill and Ford 1993)</a></li><li><a href="ex_cross.html#with-inefficiency-determinants-and-production-uncertainty">with inefficiency determinants and production uncertainty</a></li></ul></ul><li><a href="ex_cross.html#Normal-Truncated-Normal">Normal Truncated-Normal</a></li><ul><ul><li><a href="ex_cross.html#vanilla-[(Stevenson-1980)](@ref-literature)">vanilla (Stevenson 1980)</a></li><li><a href="ex_cross.html#inefficiency-determinants-in-\\mu-[(Kumbhakar,-Ghosh,-and-McGuckin,-1991;-Huang-and-Liu,-1994;-Battese-and-Coelli,-1995)](@ref-literature)">inefficiency determinants in <span>$\mu$</span> (Kumbhakar, Ghosh, and McGuckin, 1991; Huang and Liu, 1994; Battese and Coelli, 1995)</a></li><li><a href="ex_cross.html#inefficiency-determinants-in-\\mu-and-\\sigma_u2,-*aka*-the-non-monotonic-effecct-model-([Wang-2002](@ref-literature))">inefficiency determinants in <span>$\mu$</span> and <span>$\sigma_u^2$</span>, <em>aka</em> the non-monotonic effecct model (Wang 2002)</a></li></ul></ul><li><a href="ex_cross.html#Normal-Truncated-Normal-with-the-Scaling-Property">Normal Truncated-Normal with the Scaling Property</a></li><ul><ul><li><a href="ex_cross.html#the-specification-([Wang-and-Schmidt-2002,-Alvarez,-Amsler,-and-Schmidt-2006](@ref-literature))">the specification (Wang and Schmidt 2002, Alvarez, Amsler, and Schmidt 2006)</a></li></ul></ul><li><a href="ex_cross.html#Normal-Exponential">Normal Exponential</a></li></ul></ul><h3 id="The-Setup"><a class="docs-heading-anchor" href="#The-Setup">The Setup</a><a id="The-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#The-Setup" title="Permalink"></a></h3><p>Consider the following setup:</p><p class="math-container">\[ \mathbf{y}  =  \mathbf{x} \beta + \mathbf{v} - \mathbf{u},\]</p><p>where <span>$\mathbf{y}$</span> is <span>$(N\times 1)$</span>, <span>$\mathbf{x}$</span> is <span>$(N\times k)$</span> and includes a column of 1 for intercept, and <span>$\beta$</span> is <span>$(k \times 1)$</span>. <span>$\mathbf{v}$</span> and <span>$\mathbf{u}$</span> are from random variables assumed to follow certain distribution assumptions. </p><p>We use <span>$x_i$</span> (which is (<span>$1 \times k$</span>)) to denote the <span>$i$</span>th observation of <span>$\mathbf{x}$</span>. Other notations follow similarly. The specification of the Battese and Coelli (1995) model is thus:</p><p class="math-container">\[\begin{aligned}
 y_i &amp; = x_i \beta + \epsilon_i,\\
 \epsilon_i &amp; = v_i - u_i,\\
 v_i &amp; \sim N(0, \sigma_v^2),\\
 u_i &amp; \sim N^+(\mu, \sigma_u^2),\\
 \mu &amp; = z_i \delta.
 \end{aligned}\]</p><p>Here, <span>$N^+(\mu, \sigma_u^2)$</span> denotes a <em>truncated normal distribution</em> obtained by truncating the normal distribution <span>$N(\mu, \sigma_u^2)$</span> from below at 0. The <span>$\mu$</span> and <span>$\sigma_u^2$</span> are thus the mean and the variance of the normal distribution <em>before</em> the truncation. <span>$z_i$</span> is a vector of exogenous determinants of inefficiency. Lastly, the variance parameters <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are parameterized using exponential functions to ensure positive values. That is,</p><p class="math-container">\[  \sigma_v^2 = \exp(c_v),\\
  \sigma_u^2 = \exp(c_u),  \]</p><p>where <span>$\{c_v, \ c_u \} \in R$</span> are unrestricted constant, and the log-likelihood maximization is w.r.t. <span>$\{c_v, \ c_u\}$</span> (among others).</p><h4 id="the-goal"><a class="docs-heading-anchor" href="#the-goal">the goal</a><a id="the-goal-1"></a><a class="docs-heading-anchor-permalink" href="#the-goal" title="Permalink"></a></h4><p>Our goals of the model estimation include:</p><ul><li>estimate model parameters <span>$\{\beta, \delta, \sigma_v^2, \sigma_u^2 \}$</span>,</li><li>compute the inefficiency index <span>$E[u_i | \epsilon_i]|_{\epsilon_i =\hat{\epsilon}_i}$</span> and the efficiency index <span>$E[\exp(-u_i) | \epsilon_i]|_{\epsilon_i =\hat{\epsilon}_i}$</span> at the observation level,</li><li>calculate the marginal effect of <span>$z_i$</span> on <span>$E(u_i)$</span>.</li></ul><h3 id="Step-1:-Model-Specification-using-sfmodel_spec()"><a class="docs-heading-anchor" href="#Step-1:-Model-Specification-using-sfmodel_spec()">Step 1: Model Specification using <code>sfmodel_spec()</code></a><a id="Step-1:-Model-Specification-using-sfmodel_spec()-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Model-Specification-using-sfmodel_spec()" title="Permalink"></a></h3><p>We use the production data from paddy farmers in India as the empirical example. The <span>$\mathbf{y}$</span> is the annual rice production and <span>$\mathbf{x}$</span> is agricultural inputs. </p><p>There are two ways to provide data to <strong>Sfmodel</strong> for estimation. One is to use data from a DataFrame where column names of the data are variable names. The other is to use data from matrix or vectors. The latter is the likely scenario in simulation studies where we generate data matrix and feed them to the model. Different ways of providing data would require slightly different specifications of <code>sfmodel_spec()</code>. </p><p>Since the farmers data is formatted, it is natural to use the DataFrame approach. We will show the matrix approach later.</p><h4 id="using-DataFrame-data"><a class="docs-heading-anchor" href="#using-DataFrame-data">using DataFrame data</a><a id="using-DataFrame-data-1"></a><a class="docs-heading-anchor-permalink" href="#using-DataFrame-data" title="Permalink"></a></h4><p>Our farmers dataset is in the <code>.csv</code> format and we read it in using the <code>CSV</code> package and save it as a DataFrame with the name <code>df</code>.</p><pre><code class="language-julia hljs">using SFrontiers, Optim    # main packages
using DataFrames, CSV   # handling data

df = CSV.read(&quot;sampledata.csv&quot;, DataFrame; header=1, delim=&quot;,&quot;)
df[!, :_cons] .= 1.0;         # append a column of 1 to be used as a constant</code></pre><p>Note that we append a column of 1 to <code>df</code> with the column name <code>_cons</code>. Including this constant variable is essential because we will use it to estimate constant parameters; more on this later. Before estimation, users should make sure that <code>df</code> contains no missing values or any anomaly that may affect the estimation.</p><p>Now we tell <strong>SFrontiers</strong> the type of model we want to estimate and its variable specifications. The following specification indicates a Battese and Coelli (1995) type of model, since it has the truncated normal distribution on <span>$u_i$</span> and <span>$μ$</span> is parameterized by a vector of variables.</p><pre><code class="language-julia hljs">sfmodel_spec(SFtype(prod), SFdist(trun),   
             @depvar(yvar),  
             @frontier(Lland, PIland, Llabor, Lbull, Lcost, yr, _cons),    
             @μ(age, school, yr, _cons),    
             @σᵤ²(_cons),
             @σᵥ²(_cons))</code></pre><ul><li><code>SFtype(prod)</code> indicates a production-frontier type of model. The alternative is <code>cost</code> for cost frontier where the composed error is <span>$v_i + u_i$</span>.</li><li><code>SFdist(trun)</code> specifies the truncated-normal distribution assumption on <span>$u_i$</span>. Alternatives include <code>half</code>, <code>expo</code>, and <code>trun_scaling</code>.</li><li><code>@depvar(.)</code> specifies the dependent variable.</li><li><code>@frontier(.)</code> specifies the list of variables used in the frontier equation (i.e., the data of <span>$\mathbf{x}$</span>). The variables are assumes to be linear in the equation.</li><li><code>@μ(.)</code> (or <code>@mu(.)</code>) specifies the variables of inefficiency determinants as a linear function in <code>μ</code>.</li><li><code>@σᵤ²(.)</code> (or <code>@sigma_u_2(.)</code>) and <code>@σᵥ²(.)</code> (or <code>@sigma_v_2(.)</code>) specify the variables to parameterize the variances. Note that here we include only the variable <code>_cons</code> and so <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are both estimated as constant parameters.</li></ul><p>Note how the constant parameters <span>$\sigma_v^2$</span> and <span>$\sigma_u^2$</span> are estimated. Recall that we mentioned the programming trick of using <span>$\sigma_u^2 = \exp(c_u)$</span> in the likelihood function. Here, <span>$c_u$</span> is simply the coefficient of <span>$\mathrm{\_cons}$</span>. Similar for <span>$\sigma_v^2$</span>.</p><div class="admonition is-success"><header class="admonition-header">Note on intercepts and constant parameters</header><div class="admonition-body"><p><strong>SFrontiers</strong> estimates intercepts and constant parameters as the coefficients of a constant variable. That is, if a parameter is constant, <strong>SFrontiers</strong> requires a variable with values equal to 1. This is true for all equations. </p></div></div><h4 id="using-matrix-data-(*alternative-data-input*)"><a class="docs-heading-anchor" href="#using-matrix-data-(*alternative-data-input*)">using matrix data (<em>alternative data input</em>)</a><a id="using-matrix-data-(*alternative-data-input*)-1"></a><a class="docs-heading-anchor-permalink" href="#using-matrix-data-(*alternative-data-input*)" title="Permalink"></a></h4><p>As aforementioned, in addtion to DataFrame data for estimation could also come in the form of matrix and vectors, though the syntax of <code>sfmodel_spec()</code> would be slightly different. Here is a simple example of a normal half-normal model with the number of observations equal 300. </p><pre><code class="language-julia hljs">using SFrontiers, Random, Distributions

cons, x, v = ones(300,1), [randn(300, 2) ones(300,1)], randn(300,1)    

disTN = TruncatedNormal(0.0, 1.0, 0.0, Inf)    # half-normal dist with std dev = 1
u = rand(disTN, (300,1))                       # draw from half-normal r.v. 

y = x*ones(3)*0.5 .+ v .- u

sfmodel_spec(SFtype(prod),  SFdist(half),   
             depvar(y),  frontier(x),  σᵤ²(cons),  σᵥ²(cons))</code></pre><p>Note that the only difference in the syntax is using the function type of equation names (e.g., <code>depvar()</code>) instead of the macro type names (e.g., <code>@depvar()</code>). The rest of the estimation procedures are the same.</p><div class="admonition is-success"><header class="admonition-header">Note on `@depvar( )` vs. `depvar( )`</header><div class="admonition-body"><p>Macro type of equation names (<code>@depvar()</code>, <code>@frontier()</code>, <code>@μ()</code>, etc.) are used only when the arguments are column names from DataFrames. For everything else, function type of equation names (<code>depvar()</code>, <code>frontier()</code>, <code>μ()</code>, etc.) are used.</p></div></div><h3 id="Step-2:-Initial-Values-using-sfmodel_init()-*(optional)*"><a class="docs-heading-anchor" href="#Step-2:-Initial-Values-using-sfmodel_init()-*(optional)*">Step 2: Initial Values using <code>sfmodel_init()</code> <em>(optional)</em></a><a id="Step-2:-Initial-Values-using-sfmodel_init()-*(optional)*-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Initial-Values-using-sfmodel_init()-*(optional)*" title="Permalink"></a></h3><p>Providing initial values is optional. You could skip it entirely or prvodie initial values only to a partial list of the equations. If missing (all or part of the equations), default values will be used. Currently, the default uses the OLS estimates as initial values for coefficients in <code>frontier()</code> and <span>$0.1$</span> for all of the other parameters. The following example shows a mix of the strategies.</p><pre><code class="language-julia hljs">b1 = ones(4)*(0.1)

sfmodel_init(    # frontier(), # use default
             μ(b1),            # provide by a vector
                 # σᵤ²(-0.1),  # use default
             σᵥ²(-0.1))        # provide by a scalar</code></pre><ul><li>The order of equations in <code>sfmodel_init()</code> is not important. You can put <code>μ()</code> before or after <code>σᵥ²()</code>, it does not matter.</li><li>The function type of equation names (e.g., <code>frontier()</code>, <code>μ()</code>, etc.) are used in <code>sfmodel_init()</code>.</li><li>Initial values specified in <code>σᵥ²()</code> is w.r.t. the <span>$c_v$</span> as in <span>$\sigma_v^2 = \exp(c_v)$</span>. Put differently, the initial value is w.r.t. <span>$\log(\sigma_v^2)$</span>. Same for <code>σᵤ²()</code>. If we put <code>σᵥ²(-0.1)</code>, it means we have in mind the initial value of <span>$\sigma_v^2$</span> being <span>$\exp(-0.1) = 0.905$</span>.</li></ul><div class="admonition is-success"><header class="admonition-header">Note on name conflict</header><div class="admonition-body"><p><strong>SFrontiers</strong> uses names such as <code>μ</code>, <code>σᵥ²</code>, <code>gamma</code>, <code>depvar</code>, <code>frontier</code>, etc.. If the names are also used elsewhere in the program for different purposes (for instance, using <code>μ</code> to denote the value of a parameter), or users import other packages that use the same names, the name conflicts would arise. Signs of the problem include error messages such as </p><pre><code class="nohighlight hljs">MethodError: objects of type ... are not callable</code></pre><p>There are simple ways to work around:</p><ul><li>Use fully qualified function names. For instance, use <code>SFrontiers.σᵥ²</code> instead of <code>σᵥ²</code>.</li><li>Use alias if there is one. For instance, use <code>sigma_v_2</code> instead of <code>σᵥ²</code>. Check the section of <code>API Reference</code> for more information.</li></ul></div></div><h3 id="Step-3:-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*"><a class="docs-heading-anchor" href="#Step-3:-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*">Step 3: Maximization Options (and others) using <code>sfmodel_opt()</code> <em>(optional)</em></a><a id="Step-3:-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Maximization-Options-(and-others)-using-sfmodel_opt()-*(optional)*" title="Permalink"></a></h3><p>The main purpose of this function is to choose options for the numerical maximization process, including the choice of optimization algorithms, the maximum number of iterations, the convergence criterion, and others. <strong>SFrontiers</strong> uses Julia&#39;s <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim</code></a> package to do the maximization, though only a subset of <code>Optim</code>&#39;s options are directly accessible through <code>sfmodel_init()</code>.</p><p>An effective estimation strategy for challenging optimization problems is to use a non-gradient algorithm in the first stage (<code>warmstart</code>) for a few iterations and then switch to gradient-based algorithms in the second stage (<code>main</code>) for speed and accuracy. <strong>SFrontiers</strong> uses the two-step strategy as default.</p><p>This function is also optional. All or part of the specifications may be skipped. If missing, default values will be used. The following example uses the default values.</p><pre><code class="language-julia hljs">sfmodel_opt(warmstart_solver(NelderMead()),   
            warmstart_maxIT(100),
            main_solver(Newton()), 
            main_maxIT(2000), 
            tolerance(1e-8))</code></pre><ul><li><code>warmstart_solver(NelderMead())</code>: specifies the <code>Nelder-Mead</code> algorithm in the first stage estimation. Mind the braces &quot;<code>()</code>&quot; which is part of the algorithm name. Using a non-gradient algorithm in the first stage is recommended.</li><li><code>warmstart_maxIT(100)</code> and <code>main_maxIT(2000)</code>: the maximum numbers of iterations in the first and the second stage estimation.</li><li><code>main_solver(Newton())</code>: specifies the <code>Newton</code> method in the second stage estimation. </li><li><code>tolerance(1e-8)</code>: set the convergence criterion, which is with respect to the absolute tolerance in the gradient, to <code>1e-8</code>. For non-gradient algorithms, it controls the main convergence tolerance, which is solver specific. This is a wrapper of <code>Optim</code>&#39;s <code>g_tol</code> option.</li></ul><p>If the two-stage strategy is not required, we can skip the <code>warmstart</code> stage by giving empty keyword values to the first stage options, such as <code>warmstart_solver()</code> or <code>warmstart_maxIT()</code>, or both. Note that if we simply skip the keywords (i.e., missing <code>warmstart_solver</code> or <code>warmstart_maxIT</code> entirely), the default will be reinstate. Again, the first stage estimation will only be skipped when empty values are explicitly given to the related options.</p><p>In <strong>SFrontiers</strong>, <em>missing</em> = &quot;<em>Whatever. Just give me the default</em>&quot;, and <em>empty value</em> = &quot;<em>I know, but I don&#39;t want it</em>&quot;.</p><p>In addition to controlling the maximization procedures, <code>sfmodel_opt()</code> also provides options to control other things. They and their default values are the follows. </p><ul><li><code>banner(true)</code>: show banner to help to visually identify the start of the estimation. </li><li><code>verbose(true)</code>: show interim and final results.</li><li><code>ineff_index(true)</code>: compute the Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1987) efficiency index.</li><li><code>marginal(true)</code>: calculate the marginal effect of the inefficiency determinants (if any) on the unconditional mean of inefficiency.</li></ul><p>Turning these options to <code>false</code> may sometimes be desirable particularly in simulation settings.</p><h3 id="Step-4:-Estimation-using-sfmodel_fit()"><a class="docs-heading-anchor" href="#Step-4:-Estimation-using-sfmodel_fit()">Step 4: Estimation using <code>sfmodel_fit()</code></a><a id="Step-4:-Estimation-using-sfmodel_fit()-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Estimation-using-sfmodel_fit()" title="Permalink"></a></h3><p>Step 1 to 3 prepare the model, and now we are ready to estimate it. We use <code>sfmodel_fit()</code> to start the estimation, and it returns a dictionary containing estimation results and other information of the model. In the following example, we save the returned dictionary in <code>res</code>.</p><pre><code class="language-julia hljs">res = sfmodel_fit(useData(df))  # df is the DataFrame</code></pre><ul><li><code>useData(df)</code>: name of the DataFrame (see Step 1).</li></ul><p>If the estimation data is from matrix and vectors (see ...), the <code>useData()</code> option is not required. In that case, we simply do the following line.</p><pre><code class="language-julia hljs">res = sfmodel_fit()   # data from matrix / vector </code></pre><h3 id="Step-5:-Results-and-Post-Estimation-Analysis"><a class="docs-heading-anchor" href="#Step-5:-Results-and-Post-Estimation-Analysis">Step 5: Results and Post Estimation Analysis</a><a id="Step-5:-Results-and-Post-Estimation-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Results-and-Post-Estimation-Analysis" title="Permalink"></a></h3><p>The main estimation results are shown in the terminal after it is done. Let&#39;s see what we have.</p><pre><code class="nohighlight hljs">*********************************
       Estimation Results:
*********************************
Model type: the normal and truncated-normal model of Battese and Coelli (1995, JoE)
Number of observations: 271
Number of total iterations: 114
Converged successfully: true
Log-likelihood value: -87.21356

┌──────────┬────────┬─────────┬──────────┬──────────┬────────┬─────────┬─────────┐
│          │   Var. │   Coef. │ Std.Err. │        z │  P&gt;|z| │ 95%CI_l │ 95%CI_u │
├──────────┼────────┼─────────┼──────────┼──────────┼────────┼─────────┼─────────┤
│ frontier │  Lland │  0.3030 │   0.0704 │   4.3024 │ 0.0000 │  0.1650 │  0.4410 │
│          │ PIland │  0.2479 │   0.1762 │   1.4069 │ 0.1607 │ -0.0975 │  0.5933 │
│          │ Llabor │  1.1265 │   0.0843 │  13.3658 │ 0.0000 │  0.9613 │  1.2917 │
│          │  Lbull │ -0.4038 │   0.0602 │  -6.7130 │ 0.0000 │ -0.5217 │ -0.2859 │
│          │  Lcost │  0.0142 │   0.0130 │   1.0915 │ 0.2761 │ -0.0113 │  0.0396 │
│          │     yr │  0.0146 │   0.0104 │   1.4028 │ 0.1619 │ -0.0058 │  0.0350 │
│          │  _cons │  1.6699 │   0.3612 │   4.6234 │ 0.0000 │  0.9620 │  2.3778 │
│        μ │    age │ -0.0045 │   0.0144 │  -0.3154 │ 0.7527 │ -0.0327 │  0.0236 │
│          │ school │  0.0304 │   0.0701 │   0.4336 │ 0.6650 │ -0.1070 │  0.1678 │
│          │     yr │ -0.2238 │   0.2263 │  -0.9889 │ 0.3237 │ -0.6674 │  0.2198 │
│          │  _cons │ -0.1747 │   1.4744 │  -0.1185 │ 0.9058 │ -3.0644 │  2.7150 │
│  log_σᵤ² │  _cons │ -0.4083 │   1.0082 │  -0.4050 │ 0.6858 │ -2.3842 │  1.5677 │
│  log_σᵥ² │  _cons │ -3.2328 │   0.2984 │ -10.8324 │ 0.0000 │ -3.8177 │ -2.6479 │
└──────────┴────────┴─────────┴──────────┴──────────┴────────┴─────────┴─────────┘

Convert the constant log-parameter to its original scale, e.g., σ² = exp(log_σ²):
┌─────┬────────┬──────────┐
│     │  Coef. │ Std.Err. │
├─────┼────────┼──────────┤
│ σᵤ² │ 0.6648 │   0.6702 │
│ σᵥ² │ 0.0394 │   0.0118 │
└─────┴────────┴──────────┘

***** Additional Information *********
* OLS (frontier-only) log-likelihood: -104.96993
* Skewness of OLS residuals: -0.70351
* The sample mean of the JLMS inefficiency index: 0.33006
* The sample mean of the BC efficiency index: 0.74921

* The sample mean of inefficiency determinants&#39; marginal effects on E(u): (age = -0.00061, school = 0.00407, yr = -0.02997)
* Marginal effects of the inefficiency determinants at the observational level are saved in the return. See the follows.

* Use `name.list` to see saved results (keys and values) where `name` is the return specified in `name = sfmodel_fit(..)`. Values may be retrieved using the keys. For instance:
   ** `name.loglikelihood`: the log-likelihood value of the model;
   ** `name.jlms`: Jondrow et al. (1982) inefficiency index;
   ** `name.bc`: Battese and Coelli (1988) efficiency index;
   ** `name.marginal`: a DataFrame with variables&#39; (if any) marginal effects on E(u).
* Use `keys(name)` to see available keys.
**************************************</code></pre><p>As reminded in the printout, all of the shown statistics and many of the other model information are saved in the dictionary which can be called later for further investigation. Let&#39;s see the list of available keys first.</p><pre><code class="language-julia hljs">julia&gt; keys(res)   # we ave the returned dictionary in `res` in Step 4
(:converged, :iter_limit_reached, :_______________, :n_observations, :loglikelihood, :table, :coeff, :std_err, :var_cov_mat, :jlms, :bc, :OLS_loglikelihood, :OLS_resid_skew, :marginal, :marginal_mean, :_____________, :model, :depvar, :frontier, :μ, :σₐ², :σᵤ², :σᵥ², :log_σₐ², :log_σᵤ², :log_σᵥ², :type, :dist, :coeff_frontier, :coeff_μ, :coeff_log_σᵤ², :coeff_log_σᵥ², :________________, :Hessian, :gradient_norm, :actual_iterations, :______________, :warmstart_solver, :warmstart_ini, :warmstart_maxIT, :main_solver, :main_ini, :main_maxIT, :tolerance, :eqpo, :redflag, :list)</code></pre><p>Among the keywords is the term <code>:coeff</code>, which indicates the saved coefficient vector. We may retrieve the coefficient vector using <code>res.coeff</code> and save it in the name <code>b0</code> possibly for later use.</p><pre><code class="language-julia hljs">julia&gt; b0 = res.coeff
13-element Vector{Float64}:
  0.3029823393273174
  0.24794010653151866
  1.1265299143721006
 -0.4038266728402889
  0.014152608439534585
  0.014589911311642377
  1.6699115039893075
 -0.004532647263411585
  0.03039490853353706
 -0.22379268672696456
 -0.17467371095755305
 -0.40828210156522676
 -3.2327957145786477</code></pre><p>The estimation table shown above with the coefficients, standard errors, etc., may also be retrieved using the keyword <code>table</code>, though it may not be formatted as pretty.</p><h4 id="inefficiency-and-efficiency-index"><a class="docs-heading-anchor" href="#inefficiency-and-efficiency-index">inefficiency and efficiency index</a><a id="inefficiency-and-efficiency-index-1"></a><a class="docs-heading-anchor-permalink" href="#inefficiency-and-efficiency-index" title="Permalink"></a></h4><p>The Jondrow et al. (1982) inefficiency index and the Battese and Coelli (1987) efficiency index at the observation level may also be retrieved using the keywords <code>jlms</code> and <code>bc</code>. Here we show them in a <span>$N\times 2$</span> matrix.</p><pre><code class="language-julia hljs">julia&gt; [res.jlms res.bc]
271×2 Matrix{Float64}:
 0.536473   0.595487
 0.47957    0.630042
 0.0924123  0.914553
 0.239773   0.795486
 0.114407   0.89573
 ⋮
 0.410421   0.674444
 0.859055   0.431521
 0.119179   0.891702
 0.18474    0.838167
 0.169893   0.850018</code></pre><h4 id="marginal-effects"><a class="docs-heading-anchor" href="#marginal-effects">marginal effects</a><a id="marginal-effects-1"></a><a class="docs-heading-anchor-permalink" href="#marginal-effects" title="Permalink"></a></h4><p>Let&#39;s also show the marginal effects of the inefficient determinants on <span>$E(u)$</span> at the observational level, which are saved in the returned dictionary as a DataFrame object.</p><pre><code class="language-julia hljs">julia&gt; res.marginal
271×3 DataFrame
│ Row │ marg_age     │ marg_school │ marg_yr    │
│     │ Float64      │ Float64     │ Float64    │
├─────┼──────────────┼─────────────┼────────────┤
│ 1   │ -0.000482249 │ 0.00323385  │ -0.0238103 │
│ 2   │ -0.000419427 │ 0.00281258  │ -0.0207086 │
│ 3   │ -0.000366921 │ 0.00246049  │ -0.0181162 │
│ 4   │ -0.000322813 │ 0.00216471  │ -0.0159384 │
│ 5   │ -0.000285561 │ 0.00191491  │ -0.0140992 │
⋮
│ 266 │ -0.000482007 │ 0.00323223  │ -0.0237984 │
│ 267 │ -0.000419226 │ 0.00281123  │ -0.0206987 │
│ 268 │ -0.00119146  │ 0.00798967  │ -0.0588266 │
│ 269 │ -0.00100688  │ 0.00675194  │ -0.0497134 │
│ 270 │ -0.000853674 │ 0.00572455  │ -0.0421489 │
│ 271 │ -0.000727005 │ 0.00487513  │ -0.0358948 │</code></pre><h4 id="hypothesis-testing"><a class="docs-heading-anchor" href="#hypothesis-testing">hypothesis testing</a><a id="hypothesis-testing-1"></a><a class="docs-heading-anchor-permalink" href="#hypothesis-testing" title="Permalink"></a></h4><p>We may conduct a likelihood ration (LR) test to see if the frontier specification is supported by the data. The null hypothesis is that the inefficiency term <span>$u_i$</span> is not warranted and the fit of the model is no better than the OLS.</p><p>First, we calculate the test statistics using the log-likelihood values of the OLS model and the current model.</p><pre><code class="language-julia hljs">julia&gt; -2*(res.OLS_loglikelihood - res.loglikelihood)
35.51273933147917</code></pre><p>Because the test amounts to testing <span>$u_i =0$</span> which is on the boundary of the parameter&#39;s support, the appropriate distribution for the test statistic is the mixed <span>$\chi^2$</span> distribution. Critical values may be retrieved using <code>sfmodel_MixTable(dof)</code> where <code>dof</code> is the degree of freedom of the test. In this example, <code>dof=5</code> because there are five parameters involved in <span>$u_i$</span>.</p><pre><code class="language-julia hljs">julia&gt; sfmodel_MixTable(5)

  * Significance levels and critical values of the mixed χ² distribution
┌─────┬───────┬────────┬────────┬────────┐
│ dof │  0.10 │   0.05 │  0.025 │   0.01 │
├─────┼───────┼────────┼────────┼────────┤
│ 5.0 │ 8.574 │ 10.371 │ 12.103 │ 14.325 │
└─────┴───────┴────────┴────────┴────────┘

source: Table 1, Kodde and Palm (1986, Econometrica).</code></pre><p>Since the test statistic <span>$35.513$</span> is much larger than the critical value at the <span>$1\%$</span> level (which is <span>$14.325$</span>), the result overwhelmingly rejects the null hypothesis of an OLS model.</p><h4 id="predicted-values-of-equations"><a class="docs-heading-anchor" href="#predicted-values-of-equations">predicted values of equations</a><a id="predicted-values-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#predicted-values-of-equations" title="Permalink"></a></h4><p><strong>SFrontiers</strong> provides the function <code>sfmodel_predict()</code> to obtain predicted values of the equations after the model is estimated. The following example returns the predicted value of the <code>frontier</code> equation, i.e., <span>$\mathbf{x} \hat{\beta}$</span>.</p><pre><code class="language-julia hljs">julia&gt; xb = sfmodel_predict(@eq(frontier), df)
271-element Vector{Float64}:
 5.837738490387098
 5.467350523453003
 5.145107451544124
 5.494031744452952
 6.062700939460845
 6.097179092569791
 ⋮
 4.861054485639938
 6.393104647266437
 8.207717614833687
 7.894552876042939
 8.537385909249965
 6.373480344886016</code></pre><p>Note that <code>df</code> in the function is the name of the DataFrame which we had used to estimate the model. Again, if matrix and vectors are used as data input, the argument can be skipped.</p><p>As another example, we use it to predict values of <span>$\sigma_u^2$</span> for each observation, though in the current example it is trivial since <span>$\sigma_u^2$</span> is a constant.</p><pre><code class="language-julia hljs">julia&gt; sfmodel_predict(@eq( σᵤ² ), df)
271-element Vector{Float64}:
 0.6647913136972949
 0.6647913136972949
 0.6647913136972949
 ⋮
 0.6647913136972949
 0.6647913136972949
 0.6647913136972949</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 28 August 2021 18:55">Saturday 28 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
